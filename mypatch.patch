diff --git a/gemx/Makefile b/gemx/Makefile
index 21b8a32..9599210 100644
--- a/gemx/Makefile
+++ b/gemx/Makefile
@@ -138,6 +138,12 @@ else ifeq (${GEMX_part},vu9pf1)
   DSA_PLATFORM=xilinx_aws-vu9p-f1_4ddr-xpr-2pr_${DSA}
   XDEVICE_REPO_PATH=$(XILINX_SDX)/platforms/${DSA_PLATFORM}/hw
   PLATFORM_REPO_PATH=$(XILINX_SDX)/platforms/${DSA_PLATFORM}/hw
+else ifeq (${GEMX_part},kcu1500)
+  DSA=4_0
+  XDEVICE=xilinx:kcu1500:4ddr-xpr:$(subst _,.,${DSA})
+  DSA_PLATFORM=xilinx_kcu1500_4ddr-xpr_${DSA}
+  XDEVICE_REPO_PATH=$(XILINX_SDX)/platforms
+  PLATFORM_REPO_PATH=$(XILINX_SDX)/platforms/${DSA_PLATFORM}
 else
   $(error Unknown GEMX_part ${GEMX_part})
 endif
@@ -454,6 +460,11 @@ else ifeq (${GEMX_part},vu9pf1)
   K1_DDR = 2
   K2_DDR = 0
   K3_DDR = 1
+else ifeq (${GEMX_part},kcu1500)
+  K0_DDR = 0
+  K1_DDR = 1
+  K2_DDR = 2
+  K3_DDR = 3
 endif
 
 CLCC_LINK_OPT += --xp misc:map_connect=add.kernel.gemxKernel_0.M_AXI_GMEMM.core.OCL_REGION_0.M0${K0_DDR}_AXI
@@ -593,7 +604,7 @@ run_hw: host
 
 run_em_int: xconfig host xbin
 	@echo INFO: kernel xclbin frequency is $(shell ${XCLBIN_FREQ} ${XCLBIN}) MHz
-	XCL_EMULATION_MODE=true XILINX_OPENCL=${XILINX_SDX} ${HOST_EXE} ${HOST_ARGS}
+	env XCL_EMULATION_MODE=true LD_LIBRARY_PATH=${XILINX_SDX}/lib/lnx64.o:/usr/lib/x86_64-linux-gnu ${HOST_EXE} ${HOST_ARGS}
 	+make check
 
 run_multiGemm_em_int: xconfig api_gemm xbin
diff --git a/gemx/regression/run_cpu_em.sh b/gemx/regression/run_cpu_em.sh
index 6f0615e..a3a2282 100755
--- a/gemx/regression/run_cpu_em.sh
+++ b/gemx/regression/run_cpu_em.sh
@@ -5,20 +5,20 @@ echo "=============================="
 echo "Launching regressions........."
 
 #set environment
-export XILINX_SDX=/proj/xbuilds/2017.1_sdx_daily_latest/installs/lin64/SDx/2017.1
+export XILINX_SDX=/local/utils/xilinx/SDx/2017.1
 source $XILINX_SDX/settings64.sh
-export XCL_EMULATION_MODE=true
+export XCL_EMULATION_MODE=sw_emu
 
-rm -f -rf out_cpu_emu log-run_cpu_emu.txt
-rm -f -rf out_hw_emu log-run_hw_emu.txt
-rm -f -rf out_hw log-run_hw.txt
-rm -f -rf out_host sdaccel_profile* .Xil
+#rm -f -rf out_cpu_emu log-run_cpu_emu.txt
+#rm -f -rf out_hw_emu log-run_hw_emu.txt
+#rm -f -rf out_hw log-run_hw.txt
+#rm -f -rf out_host sdaccel_profile* .Xil
 
 #build kernel for cpu emu
 export s=32
 
 #build a one-kernel xclbin with GEMM engine in it
-make run_cpu_em SDA_FLOW=cpu_emu GEMX_ddrWidth=$s GEMX_argInstrWidth=`expr 32 / $s` GEMX_gemmMeshRows=$s GEMX_gemmMeshCols=$s GEMX_gemmMeshDepth=$s GEMX_gemmMBlocks=8 GEMX_gemmKBlocks=8 GEMX_gemmNBlocks=8 GEMX_numKernels=1 GEMX_runGemv=0 GEMX_runGemm=1 GEMX_runTransp=0 GEMX_runSpmv=0  GEMX_part=vu9pf1 GEMX_kernelHlsFreq=250 GEMX_kernelVivadoFreq=300 GEMX_useURAM=1 GEMX_vivadoFlow=EXP GEN_BIN_PROGRAM="gemm 512 512 512  512 512 512  A B C gemm 1024 1024 1024  1024 1024 1024  A1 B1 C1"
+#make run_cpu_em SDA_FLOW=cpu_emu GEMX_ddrWidth=$s GEMX_argInstrWidth=`expr 32 / $s` GEMX_gemmMeshRows=$s GEMX_gemmMeshCols=$s GEMX_gemmMeshDepth=$s GEMX_gemmMBlocks=8 GEMX_gemmKBlocks=8 GEMX_gemmNBlocks=8 GEMX_numKernels=1 GEMX_runGemv=0 GEMX_runGemm=1 GEMX_runTransp=0 GEMX_runSpmv=0  GEMX_part=kcu1500 GEMX_kernelHlsFreq=100 GEMX_kernelVivadoFreq=100 GEMX_useURAM=0 GEMX_vivadoFlow=EXP GEN_BIN_PROGRAM="gemm 512 512 512  512 512 512  A B C gemm 1024 1024 1024  1024 1024 1024  A1 B1 C1"
 
 GEMX_HOST_DIR=out_host
 GEMX_CPU_DIR=out_cpu_emu
@@ -26,11 +26,11 @@ GEMX_CPU_DIR=out_cpu_emu
 #launch the application
 echo "test cpu emu" 
 nice ${GEMX_HOST_DIR}/gemx_host.exe  ${GEMX_CPU_DIR}/gemx.xclbin  ${GEMX_HOST_DIR}/app.bin  ${GEMX_CPU_DIR}/app_out.bin
-nice ${GEMX_HOST_DIR}/gemx_gen_bin.exe -read ${GEMX_CPU_DIR}/app_out.bin > ${GEMX_CPU_DIR}/app_out.txt
+nice ${GEMX_HOST_DIR}/gemx_gen_bin.exe -read ${GEMX_CPU_DIR}/app_out0.bin > ${GEMX_CPU_DIR}/app_out.txt
 echo INFO: Board performance data
 head -22 ${GEMX_CPU_DIR}/app_out.txt
 echo INFO: Comparing app_gold.bin app_out.bin
-cmp -i 8192 ${GEMX_HOST_DIR}/app_gold.bin ${GEMX_CPU_DIR}/app_out.bin || ${GEMX_HOST_DIR}/gemx_gen_bin.exe -compare 1e-3 3e-6  ${GEMX_HOST_DIR}/app_gold.bin ${GEMX_CPU_DIR}/app_out.bin && echo INFO: Host Testbench ended Correctness test Status PASS
+cmp -i 8192 ${GEMX_HOST_DIR}/app_gold.bin ${GEMX_CPU_DIR}/app_out0.bin || ${GEMX_HOST_DIR}/gemx_gen_bin.exe -compare 1e-3 3e-6  ${GEMX_HOST_DIR}/app_gold.bin ${GEMX_CPU_DIR}/app_out0.bin && echo INFO: Host Testbench ended Correctness test Status PASS
 
 echo "Launching regressions.....DONE"
 echo "=============================="
diff --git a/gemx/src/gemx_api_gemm.cpp b/gemx/src/gemx_api_gemm.cpp
index 9328b85..02878aa 100644
--- a/gemx/src/gemx_api_gemm.cpp
+++ b/gemx/src/gemx_api_gemm.cpp
@@ -76,6 +76,7 @@ bool checkDim(unsigned int p_Val, unsigned int p_Mod, unsigned int p_Min) {
 
 float getBoardFreqMHz(unsigned int p_BoardId) {
   std::string l_freqCmd = "$XILINX_OPENCL/runtime/bin/xbsak query -d" + std::to_string(p_BoardId);;
+  std::cout <<"DEBUG: query board info with command - " << l_freqCmd << std::endl;
   float l_freq = -1;
   char l_lineBuf[256];
   std::shared_ptr<FILE> l_pipe(popen(l_freqCmd.c_str(), "r"), pclose);
@@ -84,7 +85,7 @@ float getBoardFreqMHz(unsigned int p_BoardId) {
   bool l_nextLine_isFreq = false;
   while (l_pipe && fgets(l_lineBuf, 256, l_pipe.get()) ) {
     std::string l_line(l_lineBuf);
-    //std::cout << "DEBUG: read line " << l_line << std::endl;
+    std::cout << "DEBUG: read line " << l_line << std::endl;
     if (l_nextLine_isFreq) {
       std::string l_prefix, l_val, l_mhz;
       std::stringstream l_ss(l_line);
diff --git a/gemx/src/gemx_gen_bin.cpp b/gemx/src/gemx_gen_bin.cpp
index b4ac159..0941868 100644
--- a/gemx/src/gemx_gen_bin.cpp
+++ b/gemx/src/gemx_gen_bin.cpp
@@ -48,6 +48,7 @@
 
 int main(int argc, char** argv)
 {
+  printf("gemx_gen_bin::main() start\n");
   if (argc < 3 ){
     printf("ERROR: passed %d arguments instead of %d, exiting\n",
            argc, 3);
@@ -338,6 +339,8 @@ int main(int argc, char** argv)
   } else {
     assert(0); // Unknown user command
   }
+
+  printf("gemx_gen_bin::main() end succefully\n");
   
   return EXIT_SUCCESS;
 }
diff --git a/gemx/src/gemx_main.cpp b/gemx/src/gemx_main.cpp
index 0fa0ba9..3caacd9 100644
--- a/gemx/src/gemx_main.cpp
+++ b/gemx/src/gemx_main.cpp
@@ -50,6 +50,7 @@
 #include <vector>
 #include <iomanip>
 
+#include <CL/opencl.h>
 #include "gemx_kernel.h"
 #if TEST_SDX
   #include "gemx_fpga.h"
@@ -131,6 +132,300 @@ writeBinFile(std::string p_BinFileName, std::vector<DdrType> &p_MemVec)
   }
 #endif
 
+template <typename T>
+T convert(const char* data) {
+    return *reinterpret_cast<const T*>(data);
+}
+
+#define ENUM_CASE(ENUM)     \
+    case ENUM:              \
+        printf(#ENUM "\n"); \
+        break
+
+#define BITFIELD_SETUP(type)                  \
+    auto value = convert<type>(field.data()); \
+    printf("[ ")
+
+#define BITFIELD_PRINT(FIELD) \
+    if (value & FIELD) {      \
+        printf(#FIELD " ");   \
+    }
+
+#define BITFIELD_END() printf("]\n")
+
+std::pair<int, const char*> platform_info[] = {
+    {CL_PLATFORM_PROFILE, "profile"},
+    {CL_PLATFORM_VERSION, "version"},
+    {CL_PLATFORM_NAME, "name"},
+    {CL_PLATFORM_VENDOR, "vendor"},
+    {CL_PLATFORM_EXTENSIONS, "extensions"}};
+
+std::pair<int, const char*> device_info[] = {
+    {CL_DEVICE_TYPE, "type"},
+    {CL_DEVICE_VENDOR_ID, "vendor id"},
+    {CL_DEVICE_MAX_COMPUTE_UNITS, "max compute units"},
+    {CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, "max work item dimensions"},
+    {CL_DEVICE_MAX_WORK_GROUP_SIZE, "max work group size"},
+    {CL_DEVICE_MAX_WORK_ITEM_SIZES, "max work item sizes"},
+    {CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR, "preferred vector width char"},
+    {CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT, "preferred vector width short"},
+    {CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT, "preferred vector width int"},
+    {CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG, "preferred vector width long"},
+    {CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT, "preferred vector width float"},
+    {CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE, "preferred vector width double"},
+    {CL_DEVICE_MAX_CLOCK_FREQUENCY, "max clock frequency"},
+    {CL_DEVICE_ADDRESS_BITS, "address bits"},
+    {CL_DEVICE_MAX_READ_IMAGE_ARGS, "max read image args"},
+    {CL_DEVICE_MAX_WRITE_IMAGE_ARGS, "max write image args"},
+    {CL_DEVICE_MAX_MEM_ALLOC_SIZE, "max mem alloc size"},
+    {CL_DEVICE_IMAGE2D_MAX_WIDTH, "image2d max width"},
+    {CL_DEVICE_IMAGE2D_MAX_HEIGHT, "image2d max height"},
+    {CL_DEVICE_IMAGE3D_MAX_WIDTH, "image3d max width"},
+    {CL_DEVICE_IMAGE3D_MAX_HEIGHT, "image3d max height"},
+    {CL_DEVICE_IMAGE3D_MAX_DEPTH, "image3d max depth"},
+    {CL_DEVICE_IMAGE_SUPPORT, "image support"},
+    {CL_DEVICE_MAX_PARAMETER_SIZE, "max parameter size"},
+    {CL_DEVICE_MAX_SAMPLERS, "max samplers"},
+    {CL_DEVICE_MEM_BASE_ADDR_ALIGN, "mem base addr align"},
+    {CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE, "min data type align size"},
+    {CL_DEVICE_SINGLE_FP_CONFIG, "single fp config"},
+    {CL_DEVICE_GLOBAL_MEM_CACHE_TYPE, "global mem cache type"},
+    {CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE, "global mem cacheline size"},
+    {CL_DEVICE_GLOBAL_MEM_CACHE_SIZE, "global mem cache size"},
+    {CL_DEVICE_GLOBAL_MEM_SIZE, "global mem size"},
+    {CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, "max constant buffer size"},
+    {CL_DEVICE_MAX_CONSTANT_ARGS, "max constant args"},
+    {CL_DEVICE_LOCAL_MEM_TYPE, "local mem type"},
+    {CL_DEVICE_LOCAL_MEM_SIZE, "local mem size"},
+    {CL_DEVICE_ERROR_CORRECTION_SUPPORT, "error correction support"},
+    {CL_DEVICE_PROFILING_TIMER_RESOLUTION, "profiling timer resolution"},
+    {CL_DEVICE_ENDIAN_LITTLE, "endian little"},
+    {CL_DEVICE_AVAILABLE, "available"},
+    {CL_DEVICE_COMPILER_AVAILABLE, "compiler available"},
+    {CL_DEVICE_EXECUTION_CAPABILITIES, "execution capabilities"},
+    {CL_DEVICE_QUEUE_PROPERTIES, "queue properties"},
+    {CL_DEVICE_NAME, "name"},
+    {CL_DEVICE_VENDOR, "vendor"},
+    {CL_DRIVER_VERSION, "version"},
+    {CL_DEVICE_PROFILE, "profile"},
+    {CL_DEVICE_VERSION, "version"},
+    {CL_DEVICE_EXTENSIONS, "extensions"},
+    {CL_DEVICE_PLATFORM, "platform"},
+    {CL_DEVICE_DOUBLE_FP_CONFIG, "double fp config"},
+    {CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF, "preferred vector width half"},
+    {CL_DEVICE_HOST_UNIFIED_MEMORY, "host unified memory"},
+    {CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR, "native vector width char"},
+    {CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT, "native vector width short"},
+    {CL_DEVICE_NATIVE_VECTOR_WIDTH_INT, "native vector width int"},
+    {CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG, "native vector width long"},
+    {CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT, "native vector width float"},
+    {CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE, "native vector width double"},
+    {CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF, "native vector width half"},
+    {CL_DEVICE_OPENCL_C_VERSION, "opencl c version"},
+    {CL_DEVICE_LINKER_AVAILABLE, "linker available"},
+    {CL_DEVICE_BUILT_IN_KERNELS, "built in kernels"},
+    {CL_DEVICE_IMAGE_MAX_BUFFER_SIZE, "image max buffer size"},
+    {CL_DEVICE_IMAGE_MAX_ARRAY_SIZE, "image max array size"},
+    {CL_DEVICE_PARENT_DEVICE, "parent device"},
+    {CL_DEVICE_PARTITION_MAX_SUB_DEVICES, "partition max sub devices"},
+    {CL_DEVICE_PARTITION_PROPERTIES, "partition properties"},
+    {CL_DEVICE_PARTITION_AFFINITY_DOMAIN, "partition affinity domain"},
+    {CL_DEVICE_PARTITION_TYPE, "partition type"},
+    {CL_DEVICE_REFERENCE_COUNT, "reference count"},
+    {CL_DEVICE_PREFERRED_INTEROP_USER_SYNC, "preferred interop user sync"},
+    {CL_DEVICE_PRINTF_BUFFER_SIZE, "printf buffer size"}};
+
+template <typename T, size_t N>
+int sizeof_array(T (&)[N]) {
+    return N;
+}
+
+void print_platform_info(boost::compute::platform const &platform) {
+    for (int i = 0; i < sizeof_array(platform_info); ++i) {
+        std::string str = std::move(platform.get_info<std::string>(platform_info[i].first));
+        printf("platform %-11s: %s\n", platform_info[i].second, str.c_str());
+    }
+}
+
+void print_device_info(boost::compute::device const &device) {
+    for (int i = 0; i < sizeof_array(device_info); i++) {
+        std::string field = std::move(device.get_info<std::string>(device_info[i].first));
+
+        printf("  device %-32s: ", device_info[i].second);
+        switch (device_info[i].first) {
+            case CL_DEVICE_ADDRESS_BITS:
+            case CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE:
+            case CL_DEVICE_MAX_CLOCK_FREQUENCY:
+            case CL_DEVICE_MAX_COMPUTE_UNITS:
+            case CL_DEVICE_MAX_CONSTANT_ARGS:
+            case CL_DEVICE_MAX_READ_IMAGE_ARGS:
+            case CL_DEVICE_MAX_SAMPLERS:
+            case CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS:
+            case CL_DEVICE_MAX_WRITE_IMAGE_ARGS:
+            case CL_DEVICE_MEM_BASE_ADDR_ALIGN:
+            case CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE:
+            case CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR:
+            case CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT:
+            case CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT:
+            case CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG:
+            case CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT:
+            case CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE:
+            case CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF:
+            case CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR:
+            case CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT:
+            case CL_DEVICE_NATIVE_VECTOR_WIDTH_INT:
+            case CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG:
+            case CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT:
+            case CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE:
+            case CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF:
+            case CL_DEVICE_VENDOR_ID:
+            case CL_DEVICE_PARTITION_MAX_SUB_DEVICES:
+            case CL_DEVICE_REFERENCE_COUNT:
+                printf("%d\n", convert<cl_uint>(field.data()));
+                break;
+
+            case CL_DEVICE_AVAILABLE:
+            case CL_DEVICE_COMPILER_AVAILABLE:
+            case CL_DEVICE_ENDIAN_LITTLE:
+            case CL_DEVICE_ERROR_CORRECTION_SUPPORT:
+            case CL_DEVICE_IMAGE_SUPPORT:
+            case CL_DEVICE_HOST_UNIFIED_MEMORY:
+            case CL_DEVICE_LINKER_AVAILABLE:
+            case CL_DEVICE_PREFERRED_INTEROP_USER_SYNC:
+                printf("%s\n",
+                       convert<cl_bool>(field.data()) ? "true" : "false");
+                break;
+
+            case CL_DEVICE_GLOBAL_MEM_CACHE_SIZE:
+            case CL_DEVICE_GLOBAL_MEM_SIZE:
+            case CL_DEVICE_LOCAL_MEM_SIZE:
+            case CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE:
+            case CL_DEVICE_MAX_MEM_ALLOC_SIZE:
+                printf("%lu\n", convert<cl_ulong>(field.data()));
+                break;
+
+            case CL_DEVICE_IMAGE2D_MAX_HEIGHT:
+            case CL_DEVICE_IMAGE2D_MAX_WIDTH:
+            case CL_DEVICE_IMAGE3D_MAX_DEPTH:
+            case CL_DEVICE_IMAGE3D_MAX_HEIGHT:
+            case CL_DEVICE_IMAGE3D_MAX_WIDTH:
+            case CL_DEVICE_MAX_PARAMETER_SIZE:
+            case CL_DEVICE_MAX_WORK_GROUP_SIZE:
+            case CL_DEVICE_PROFILING_TIMER_RESOLUTION:
+            case CL_DEVICE_PRINTF_BUFFER_SIZE:
+            case CL_DEVICE_IMAGE_MAX_BUFFER_SIZE:
+            case CL_DEVICE_IMAGE_MAX_ARRAY_SIZE:
+                printf("%zu\n", convert<size_t>(field.data()));
+                break;
+
+            case CL_DEVICE_MAX_WORK_ITEM_SIZES: {
+                size_t max_dim = 0;
+                max_dim = device.get_info<size_t>(CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS);
+                printf("[  ");
+                for (int i = 0; i < (int)max_dim; i++) {
+                    printf("\b%zu  ",
+                           convert<size_t>(&field[i * sizeof(size_t)]));
+                }
+                printf("\b]\n");
+            } break;
+
+            case CL_DEVICE_EXTENSIONS:
+            case CL_DEVICE_NAME:
+            case CL_DEVICE_PROFILE:
+            case CL_DEVICE_VENDOR:
+            case CL_DEVICE_VERSION:
+            case CL_DRIVER_VERSION:
+            case CL_DEVICE_BUILT_IN_KERNELS:
+            case CL_DEVICE_OPENCL_C_VERSION:
+                printf("%s\n", field.data());
+                break;
+
+            case CL_DEVICE_TYPE:
+                switch (convert<cl_device_type>(field.data())) {
+                    ENUM_CASE(CL_DEVICE_TYPE_ACCELERATOR);
+                    ENUM_CASE(CL_DEVICE_TYPE_CPU);
+                    ENUM_CASE(CL_DEVICE_TYPE_GPU);
+                    ENUM_CASE(CL_DEVICE_TYPE_DEFAULT);
+                    default:
+                        printf("UNKNOWN\n");
+                }
+                break;
+            case CL_DEVICE_GLOBAL_MEM_CACHE_TYPE:
+                switch (convert<cl_device_mem_cache_type>(field.data())) {
+                    ENUM_CASE(CL_NONE);
+                    ENUM_CASE(CL_READ_ONLY_CACHE);
+                    ENUM_CASE(CL_READ_WRITE_CACHE);
+                    default:
+                        printf("UNKNOWN\n");
+                }
+                break;
+            case CL_DEVICE_LOCAL_MEM_TYPE:
+                switch (convert<cl_device_mem_cache_type>(field.data())) {
+                    ENUM_CASE(CL_LOCAL);
+                    ENUM_CASE(CL_GLOBAL);
+                    default:
+                        printf("UNKNOWN\n");
+                }
+                break;
+            case CL_DEVICE_PARTITION_PROPERTIES:
+                switch (convert<cl_device_mem_cache_type>(field.data())) {
+                    case 0:
+                        printf("NONE\n");
+                        break;
+                        ENUM_CASE(CL_DEVICE_PARTITION_EQUALLY);
+                        ENUM_CASE(CL_DEVICE_PARTITION_BY_COUNTS);
+                        ENUM_CASE(CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN);
+                    default:
+                        printf("UNKNOWN\n");
+                }
+                break;
+            case CL_DEVICE_QUEUE_PROPERTIES: {
+                BITFIELD_SETUP(cl_command_queue_properties);
+                BITFIELD_PRINT(CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE);
+                BITFIELD_PRINT(CL_QUEUE_PROFILING_ENABLE);
+                BITFIELD_END();
+            } break;
+            case CL_DEVICE_DOUBLE_FP_CONFIG:
+            case CL_DEVICE_HALF_FP_CONFIG:
+            case CL_DEVICE_SINGLE_FP_CONFIG: {
+                BITFIELD_SETUP(cl_device_fp_config);
+                BITFIELD_PRINT(CL_FP_DENORM);
+                BITFIELD_PRINT(CL_FP_INF_NAN);
+                BITFIELD_PRINT(CL_FP_ROUND_TO_ZERO);
+                BITFIELD_PRINT(CL_FP_ROUND_TO_INF);
+                BITFIELD_PRINT(CL_FP_FMA);
+                BITFIELD_PRINT(CL_FP_SOFT_FLOAT);
+                BITFIELD_END();
+            } break;
+            case CL_DEVICE_EXECUTION_CAPABILITIES: {
+                BITFIELD_SETUP(cl_device_exec_capabilities);
+                BITFIELD_PRINT(CL_EXEC_KERNEL);
+                BITFIELD_PRINT(CL_EXEC_NATIVE_KERNEL);
+                BITFIELD_END();
+            } break;
+            case CL_DEVICE_PARTITION_AFFINITY_DOMAIN: {
+                BITFIELD_SETUP(cl_device_affinity_domain);
+                BITFIELD_PRINT(CL_DEVICE_AFFINITY_DOMAIN_NUMA);
+                BITFIELD_PRINT(CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE);
+                BITFIELD_PRINT(CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE);
+                BITFIELD_PRINT(CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE);
+                BITFIELD_PRINT(CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE);
+                BITFIELD_PRINT(CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE);
+                BITFIELD_END();
+            }
+            break;
+            case CL_DEVICE_PLATFORM: {
+                std::string field = device.platform().name();
+                printf("%s\n", field.c_str());
+            } break;
+            default:
+                printf("N/A \n");
+                continue;
+        }
+        field[0] = '\0';
+    }
+}
+
 int main(int argc, char** argv)
 {
   if (argc < 4){
@@ -156,7 +451,11 @@ int main(int argc, char** argv)
   else {
 	l_kernelNameId = l_kernelId;
   }*/
-
+  boost::compute::device device = boost::compute::system::default_device();
+  //std::cout << "Device: " << device.name() << std::endl;
+  //std::cout << "Platform: " << device.platform().name() << std::endl;
+  print_platform_info(device.platform());
+  print_device_info(device);
   printf("GEMX:   %s  %s  %s %s\n",
          argv[0], l_xclbinFile.c_str(), l_binFile.c_str(), l_binFileOut.c_str());
   
